import argparse
import csv
import os
import time
import random

import cv2

import numpy as np

from keras.layers import Lambda, Cropping2D, Conv2D, MaxPool2D
from keras.layers.core import Dense, Flatten, Dropout
from keras.models import Sequential
from keras.optimizers import Adam
from sklearn.utils import shuffle


import sklearn
from sklearn.model_selection import train_test_split

# PARAMETERS
EPOCHS = 50
BATCH_SIZE = 8
LEARNING_RATE = 2e-5


def random_flip(image, steering_angle, prob=0.5):
    if random.random() > prob:
        return np.fliplr(image), -steering_angle
    else:
        return image, steering_angle


def shear(image, steering_angle, shear_range=200):
    """
    Source: https://medium.com/@ksakmann/behavioral-cloning-make-a-car-drive-like-yourself-dc6021152713#.7k8vfppvk
    :param image:
        Source image on which the shear operation will be applied
    :param steering_angle:
        The steering angle of the image
    :param shear_range:
        Random shear between [-shear_range, shear_range + 1] will be applied
    :return:
        The image generated by applying random shear on the source image
    """
    rows, cols, ch = image.shape
    dx = np.random.randint(-shear_range, shear_range + 1)
    random_point = [cols / 2 + dx, rows / 2]
    pts1 = np.float32([[0, rows], [cols, rows], [cols / 2, rows / 2]])
    pts2 = np.float32([[0, rows], [cols, rows], random_point])
    dsteering = dx / (rows / 2) * 360 / (2 * np.pi * 25.0) / 6.0
    M = cv2.getAffineTransform(pts1, pts2)
    image = cv2.warpAffine(image, M, (cols, rows), borderMode=1)
    steering_angle += dsteering

    return image, steering_angle


def gamma_aleatory(image):
    """
    Source: https://medium.com/@ksakmann/behavioral-cloning-make-a-car-drive-like-yourself-dc6021152713#.7k8vfppvk
    gamma aleatory is used in order to pre process data and also be used as a data augmentation tecnique
    :param image:
        image
    :return:
        New image generated with the gamma correction to the source image
    """
    gamma = np.random.uniform(0.4, 1.5)
    inv_gamma = 1.0 / gamma
    table = np.array([((i / 255.0) ** inv_gamma) * 255
                      for i in np.arange(0, 256)]).astype("uint8")
    # apply gamma correction using the lookup table
    return cv2.LUT(image, table)


def augment_brightness_camera_images(image):
    """
    Source: https://medium.com/@ksakmann/behavioral-cloning-make-a-car-drive-like-yourself-dc6021152713#.7k8vfppvk
    :param image: image to be augmented
    :return: brightness augmented image
    """
    image1 = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)
    image1 = np.array(image1, dtype=np.float64)
    random_bright = .5 + np.random.uniform()
    image1[:, :, 2] = image1[:, :, 2] * random_bright
    image1[:, :, 2][image1[:, :, 2] > 255] = 255
    image1 = np.array(image1, dtype=np.uint8)
    image1 = cv2.cvtColor(image1, cv2.COLOR_HSV2RGB)
    return image1


def image_augmentation(image, steering):
    if random.random() > 0.9:
        image, steering = shear(image, steering)
    image = gamma_aleatory(augment_brightness_camera_images(image))
    return image, steering


def generator(samples, batch_size=32):
    num_samples = len(samples)
    while 1:  # Loop forever so the generator never terminates
        sklearn.utils.shuffle(samples)
        for offset in range(0, num_samples, batch_size):
            batch_samples = samples[offset:offset + batch_size]

            images = []
            angles = []
            for batch_sample in batch_samples:
                angle = float(batch_sample[3])
                correction = 0.235

                randside = random.randint(0, 2)
                name = batch_sample[randside]
                image = cv2.imread(name)
                image_flip, steering = random_flip(image, angle)

                if randside == 1:  # left
                    steering += correction
                if randside == 2:  # right
                    steering -= correction

                image, steering = image_augmentation(image, steering)
                images.append(image)
                angles.append(steering)

            # trim image to only see section with road
            x_train = np.array(images)
            y_train = np.array(angles)
            yield sklearn.utils.shuffle(x_train, y_train)


def main(dir_):
    if dir_ and os.path.isdir(dir_):
        os.chdir(dir_)
    samples = []
    with open('./driving_log.csv') as csvfile:
        reader = csv.reader(csvfile)
        for line in reader:
            samples.append(line)

    train_samples, validation_samples = train_test_split(samples, test_size=0.2)

    model = Sequential()
    model.add(Cropping2D(cropping=((60, 20), (0, 0)), input_shape=(160, 320, 3)))
    model.add(Lambda(lambda x: (x / 128.0) - 1.0))

    model.add(Conv2D(24, (5, 5), activation="relu"))
    model.add(MaxPool2D((2, 2), (2, 2)))
    model.add(Conv2D(36, (5, 5), activation='relu'))
    model.add(MaxPool2D((2, 2), (2, 2)))
    model.add(Conv2D(48, (5, 5), activation='relu'))
    model.add(MaxPool2D((2, 2), (2, 2)))
    model.add(Conv2D(64, (3, 3), activation='relu'))
    model.add(Conv2D(64, (3, 3), activation='relu'))
    model.add(Dropout(0.2))
    model.add(Flatten())

    model.add(Dense(300))
    model.add(Dense(100))
    model.add(Dense(50))
    model.add(Dense(10))
    model.add(Dense(1))

    # compile and train the model using the generator function
    train_generator = generator(train_samples, batch_size=BATCH_SIZE)
    validation_generator = generator(validation_samples, batch_size=BATCH_SIZE)

    model.compile(loss='mse', optimizer=Adam(LEARNING_RATE))

    model.summary()

    history_object = model.fit_generator(train_generator,
                                         steps_per_epoch=np.math.ceil(len(train_samples) / BATCH_SIZE),
                                         validation_data=validation_generator,
                                         validation_steps=np.math.ceil(len(validation_samples) / BATCH_SIZE),
                                         epochs=EPOCHS, verbose=1)

    filename = "model_" + time.strftime("%Y%m%d-%H%M%S") + ".h5"
    model.save(filename)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Trains the model.')
    parser.add_argument('dir', default=os.getcwd())

    args = parser.parse_args()
    main(args.dir)
